"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JobSummary = void 0;
const core = __importStar(require("@actions/core"));
const semver_1 = require("semver");
const core_1 = require("@octokit/core");
const github = __importStar(require("@actions/github"));
const util_1 = require("util");
const zlib_1 = require("zlib");
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const http_client_1 = require("@actions/http-client");
const os_1 = require("os");
const utils_1 = require("./utils");
class JobSummary {
    /**
     * Enabling job summary is done by setting the output dir for the summaries.
     * If the output dir is not set, the CLI won't generate the summary Markdown files.
     */
    static enableJobSummaries() {
        let tempDir = this.getTempDirectory();
        utils_1.Utils.exportVariableIfNotSet(this.JFROG_CLI_COMMAND_SUMMARY_OUTPUT_DIR_ENV, tempDir);
    }
    static isJobSummarySupported() {
        const version = core.getInput(utils_1.Utils.CLI_VERSION_ARG);
        return version === utils_1.Utils.LATEST_CLI_VERSION || (0, semver_1.gte)(version, this.MIN_CLI_VERSION_JOB_SUMMARY);
    }
    /**
     * Generates GitHub workflow unified Summary report.
     * This function runs as part of post-workflow cleanup function,
     * collects existing section markdown files generated by the CLI,
     * and constructs a single Markdown file, to be displayed in the GitHub UI.
     */
    static setMarkdownAsJobSummary() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Read all sections and construct the final Markdown file
                const markdownContent = yield this.readCommandSummaryMarkdown();
                if (markdownContent.length == 0) {
                    core.debug('No job summary file found. Workflow summary will not be generated.');
                    return;
                }
                // Write to GitHub's job summary
                core.summary.addRaw(markdownContent, true);
                yield core.summary.write({ overwrite: true });
            }
            catch (error) {
                core.warning(`Failed to generate Workflow summary: ${error}`);
            }
        });
    }
    /**
     * Populates the code scanning SARIF (if generated by scan commands) to the code scanning tab in GitHub.
     */
    static populateCodeScanningTab() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const encodedSarif = yield this.getCodeScanningEncodedSarif();
                if (!encodedSarif) {
                    return;
                }
                const token = process.env.JF_GIT_TOKEN;
                if (!token) {
                    console.info('No token provided for uploading code scanning sarif files.');
                    return;
                }
                yield this.uploadCodeScanningSarif(encodedSarif, token);
            }
            catch (error) {
                core.warning(`Failed populating code scanning sarif: ${error}`);
            }
        });
    }
    /**
     * Uploads the code scanning SARIF content to the code-scanning GitHub API.
     * @param encodedSarif - The final compressed and encoded sarif content.
     * @param token - GitHub token to use for the request. Has to have 'security-events: write' permission.
     * @private
     */
    static uploadCodeScanningSarif(encodedSarif, token) {
        return __awaiter(this, void 0, void 0, function* () {
            const octokit = new core_1.Octokit({ auth: token });
            let response;
            response = yield octokit.request('POST /repos/{owner}/{repo}/code-scanning/sarifs', {
                owner: github.context.repo.owner,
                repo: github.context.repo.repo,
                commit_sha: github.context.sha,
                ref: github.context.ref,
                sarif: encodedSarif,
            });
            if (response.status < 200 || response.status >= 300) {
                throw new Error(`Failed to upload SARIF file: ` + JSON.stringify(response));
            }
            core.info('SARIF file uploaded successfully');
        });
    }
    /**
     * Compresses the input sarif content using gzip and encodes it to base64. This is required by the code-scanning/sarif API.
     * @param input - The sarif content to compress and encode.
     * @returns The compressed and encoded string.
     * @private
     */
    static compressAndEncodeSarif(input) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const compressed = yield (0, util_1.promisify)(zlib_1.gzip)(input);
                return compressed.toString('base64');
            }
            catch (error) {
                throw new Error('Compression of sarif file failed: ' + error);
            }
        });
    }
    /**
     * Each section should prepare a file called markdown.md.
     * This function reads each section file and wraps it with a markdown header
     * @returns <string> the content of the markdown file as string, warped in a collapsable section.
     */
    static readCommandSummaryMarkdown() {
        return __awaiter(this, void 0, void 0, function* () {
            let markdownContent = yield this.readMarkdownContent();
            if (markdownContent === '') {
                return '';
            }
            // Check if the header can be accessed via the internet to decide if to use the image or the text header
            this.isSummaryHeaderAccessible = yield this.isHeaderPngAccessible();
            core.debug('Header image is accessible: ' + this.isSummaryHeaderAccessible);
            return this.wrapContent(markdownContent);
        });
    }
    /**
     * Reads the combined SARIF file, compresses and encodes it to match the code-scanning/sarif API requirements.
     * @returns <string[]> the paths of the code scanning sarif files.
     */
    static getCodeScanningEncodedSarif() {
        return __awaiter(this, void 0, void 0, function* () {
            const finalSarifFile = path_1.default.join(this.getJobOutputDirectoryPath(), this.SECURITY_DIR_NAME, this.SARIF_REPORTS_DIR_NAME, this.CODE_SCANNING_FINAL_SARIF_FILE);
            if (!(0, fs_1.existsSync)(finalSarifFile)) {
                console.debug('No code scanning sarif file was found.');
                return '';
            }
            // Read the SARIF file, compress and encode it to match the code-scanning/sarif API requirements.
            const sarif = yield fs_1.promises.readFile(finalSarifFile, 'utf-8');
            return yield this.compressAndEncodeSarif(sarif);
        });
    }
    static readMarkdownContent() {
        return __awaiter(this, void 0, void 0, function* () {
            const markdownFilePath = path_1.default.join(this.getJobOutputDirectoryPath(), 'markdown.md');
            if ((0, fs_1.existsSync)(markdownFilePath)) {
                return yield fs_1.promises.readFile(markdownFilePath, 'utf-8');
            }
            core.debug(`No job summary file found. at ${markdownFilePath}.`);
            return '';
        });
    }
    static getMarkdownHeader() {
        let mainTitle;
        if (this.isSummaryHeaderAccessible) {
            let platformUrl = this.getPlatformUrl();
            mainTitle = `[![JFrog Job Summary Header](${this.MARKDOWN_HEADER_PNG_URL})](${platformUrl})` + '\n\n';
        }
        else {
            mainTitle = `# üê∏ JFrog Job Summary` + '\n\n';
        }
        return mainTitle + this.getProjectPackagesLink();
    }
    /**
     * Gets the project packages link to be displayed in the summary
     * If the project is undefined, it will resolve to 'all' section in the UI.
     * @return <string> https://platformUrl/ui/packages?projectKey=projectKey
     */
    static getProjectPackagesLink() {
        let platformUrl = this.getPlatformUrl();
        if (!platformUrl) {
            return '';
        }
        let projectKey = process.env.JF_PROJECT ? process.env.JF_PROJECT : '';
        let projectPackagesUrl = platformUrl + 'ui/packages';
        if (projectKey) {
            projectPackagesUrl += '?projectKey=' + projectKey;
        }
        return `<a href="${projectPackagesUrl}"> üê∏ View package details on the JFrog platform  </a>` + '\n\n';
    }
    static getPlatformUrl() {
        let platformUrl = process.env.JF_URL;
        if (!platformUrl) {
            return '';
        }
        if (!platformUrl.endsWith('/')) {
            platformUrl = platformUrl + '/';
        }
        return platformUrl;
    }
    static getJobOutputDirectoryPath() {
        const outputDir = process.env[this.JFROG_CLI_COMMAND_SUMMARY_OUTPUT_DIR_ENV];
        if (!outputDir) {
            throw new Error('Jobs home directory is undefined, ' + this.JFROG_CLI_COMMAND_SUMMARY_OUTPUT_DIR_ENV + ' is not set.');
        }
        return path_1.default.join(outputDir, this.JOB_SUMMARY_DIR_NAME);
    }
    static clearCommandSummaryDir() {
        return __awaiter(this, void 0, void 0, function* () {
            const outputDir = this.getJobOutputDirectoryPath();
            core.debug('Removing command summary directory: ' + outputDir);
            yield fs_1.promises.rm(outputDir, { recursive: true });
        });
    }
    static wrapContent(fileContent) {
        return this.getMarkdownHeader() + fileContent + this.getMarkdownFooter();
    }
    static getMarkdownFooter() {
        return `${this.getUsageBadge()} \n\n # \n\n The above Job Summary was generated by the <a href="https://github.com/marketplace/actions/setup-jfrog-cli"> Setup JFrog CLI GitHub Action </a>`;
    }
    static getUsageBadge() {
        const platformUrl = this.getPlatformUrl();
        const githubJobId = this.getGithubJobId();
        const gitRepo = process.env.GITHUB_REPOSITORY || '';
        const runId = process.env.GITHUB_RUN_ID || '';
        const url = new URL(`${platformUrl}ui/api/v1/u`);
        url.searchParams.set(this.SOURCE_PARAM_KEY, this.SOURCE_PARAM_VALUE);
        url.searchParams.set(this.METRIC_PARAM_KEY, this.METRIC_PARAM_VALUE);
        url.searchParams.set(this.JOB_ID_PARAM_KEY, githubJobId);
        url.searchParams.set(this.RUN_ID_PARAM_KEY, runId);
        url.searchParams.set(this.GIT_REPO_PARAM_KEY, gitRepo);
        return `![](${url.toString()})`;
    }
    /**
     * Checks if the header image is accessible via the internet.
     * Saves the result in a static variable to avoid multiple checks.
     * @private
     */
    static isHeaderPngAccessible() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isSummaryHeaderAccessible != undefined) {
                return this.isSummaryHeaderAccessible;
            }
            const url = this.MARKDOWN_HEADER_PNG_URL;
            const httpClient = new http_client_1.HttpClient();
            try {
                // Set timeout to 5 seconds
                const requestOptions = {
                    socketTimeout: 5000,
                };
                const response = yield httpClient.head(url, requestOptions);
                this.isSummaryHeaderAccessible = response.message.statusCode === 200;
            }
            catch (error) {
                core.warning('No internet access to the header image, using the text header instead.');
                this.isSummaryHeaderAccessible = false;
            }
            finally {
                httpClient.dispose();
            }
            return this.isSummaryHeaderAccessible;
        });
    }
    static getTempDirectory() {
        // Determine the temporary directory path, prioritizing RUNNER_TEMP
        // Runner_Temp is set on GitHub machines, but on self-hosted it could be unset.
        const tempDir = process.env.RUNNER_TEMP || (0, os_1.tmpdir)();
        if (!tempDir) {
            throw new Error('Failed to determine the temporary directory');
        }
        return tempDir;
    }
    /**
     * Retrieves the GitHub job ID, which in this context refers to the GitHub workflow name.
     * Note: We use "job" instead of "workflow" to align with our terminology, where "GitHub job summary"
     * refers to the entire workflow summary. Here, "job ID" means the workflow name, not individual jobs within the workflow.
     */
    static getGithubJobId() {
        return process.env.GITHUB_WORKFLOW || '';
    }
}
exports.JobSummary = JobSummary;
// Directory name which holds markdown files for the Workflow summary
JobSummary.JOB_SUMMARY_DIR_NAME = 'jfrog-command-summary';
// Directory name which holds security command summary files
JobSummary.SECURITY_DIR_NAME = 'security';
// Directory name which holds sarifs files for the code scanning tab
JobSummary.SARIF_REPORTS_DIR_NAME = 'sarif-reports';
// JFrog CLI command summary output directory environment variable
JobSummary.JFROG_CLI_COMMAND_SUMMARY_OUTPUT_DIR_ENV = 'JFROG_CLI_COMMAND_SUMMARY_OUTPUT_DIR';
// Minimum JFrog CLI version supported for job summary command
JobSummary.MIN_CLI_VERSION_JOB_SUMMARY = '2.66.0';
// Code scanning sarif expected file extension.
JobSummary.CODE_SCANNING_FINAL_SARIF_FILE = 'final.sarif';
// URL for the markdown header image
// This is hosted statically because its usage is outside the context of the JFrog setup action.
// It cannot be linked to the repository, as GitHub serves the image from a CDN,
// which gets blocked by the browser, resulting in an empty image.
JobSummary.MARKDOWN_HEADER_PNG_URL = 'https://media.jfrog.com/wp-content/uploads/2024/09/02161430/jfrog-job-summary.svg';
// Flag to indicate if the summary header is accessible, can be undefined if not checked yet.
JobSummary.isSummaryHeaderAccessible = undefined;
// Job ID query parameter key
JobSummary.JOB_ID_PARAM_KEY = 'job_id';
// Run ID query parameter key
JobSummary.RUN_ID_PARAM_KEY = 'run_id';
// Git repository query parameter key
JobSummary.GIT_REPO_PARAM_KEY = 'git_repo';
// Source query parameter indicating the source of the request
JobSummary.SOURCE_PARAM_KEY = 's';
JobSummary.SOURCE_PARAM_VALUE = '1';
// Metric query parameter indicating the metric type
JobSummary.METRIC_PARAM_KEY = 'm';
JobSummary.METRIC_PARAM_VALUE = '1';
